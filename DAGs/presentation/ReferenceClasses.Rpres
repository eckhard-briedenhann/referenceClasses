ReferenceClasses
========================================================
author: Rob Bennetto and Eckhard Briedenhann
css : chalcid.css
date: 2019-04-06 
autosize: true

Introduction
========================================================

Chalcid

SatRday
========================================================
```{r, echo=FALSE, fig.align="center"}
   knitr::include_graphics('./satRDay.png')
```


SatRday
========================================================
incremental: true


- What do we wear?
  - Normal clothes?
  - Formal clothes?
  - Zebra suit?

- How do we fit it in with all of our other responsibilities?
 - Will there be enough time?
 - How long will it take?
 
 - What do we do first?
  - Create presentation?
  - Code up something interesting and hope the presentation self-materialises?
  - Go find a corner to cry in?

***

```{r, echo=FALSE, fig.align="center", out.width = "70%"}
   knitr::include_graphics('./stressed.jpg')
```

How do we over engineer this?
========================================================
incremental: true

What do we need?
``` {r, echo=TRUE, fig.align="center", out.width= "100%"}
source('../graph_fns.R')
```

- A way to represent a **state** of being
- A way to represent the **transitions** between states as well as their attributes (*time, awesomeness-factor, etc.*)
- **Algorithms** to calculate the the optimal set of state to traverse

```{r, echo=FALSE, fig.align="center", out.width = "40%"}
   knitr::include_graphics('./science.jpg')
```

Graph?
========================================================



Graph?
========================================================
incremental: true

```{r, echo=FALSE, fig.align="center", out.width= "50%"}
   knitr::include_graphics('./simple_graphs/acyclic.png') 
```

Process:
* Assign weights to the transitions
* And calculate what the boundries of the states as a whole are


Rob's face
========================================================

```{r, echo=FALSE, fig.align="center", out.width= "80%"}
   knitr::include_graphics('./calc.gif')
```

DAGs
========================================================

DAGs
========================================================
incremental: true

**Directed Acyclic graphs (aka DAG)**

* Nodes (Vertices)
* Directed Edges ( pairs of nodes)
* No Cycles


```{r, echo=FALSE, fig.align="center", out.width= "30%"}
   knitr::include_graphics('./wikiDAG.png')
```

Representation problem
========================================================
incremental: true

Nodes:
```{r}
nodes <- list( n1 = list(id = 1), n2 = list(id = 2),
                n3 = list(id = 3), n4 = list(id = 4))
```

Helper functions:
```{r}
getNodeID <- function(node){
  paste0("n",node$id)
}
```

***

Vectorised Graph:
```{r}

graph <- data.frame(From = c(1,1,2,3),
                    To = c(2,3,4,4))
```

```{r ,echo=F}
graph
```
```{r, echo = F}
n1 <- list(id = 1)
n2 <- list(id = 2)
n3 <- list(id = 4)
n4 <- list(id = 4)
```

List Graph:
```{r}
graph <- list()
graph[[getNodeID(n1)]] <- list(n2,n3)
graph[[getNodeID(n2)]] <- list(n4)
graph[[getNodeID(n3)]] <- list(n4)
```
```{r, echo = F}
graph
```


========================================================

```{r, echo=FALSE, fig.align="center", out.width= "80%"}
   knitr::include_graphics('./smellyCheeseCat.gif')
```

Why does this smell funny?
========================================================
incremental: true

* **No typing** - live in the wild west
* **No standard** - reinventing the wheel one line at a time
* **No abstraction** - very verbose with a lot of index hunting

Why does this smell funny?
========================================================

* **No typing** - live in the wild west
* **No standard** - reinventing the wheel one line at a time
* **No abstraction** - very verbose with a lot of index hunting

```{r, echo=FALSE, fig.align="center", out.width= "50%"}
   knitr::include_graphics('./noTime.jpeg')
```


C++ World
========================================================
incremental: true

Object Orientated Programming:


Node Class:
```{ width = "50%"}
// Vector object
class Node {
  public:
    Node(int id):id(id){}
    int id;
};
```

Graph Class:
```

class DAG {
  public:
  
  DAG(int size) : adjList(size){}
  
  void addEdge(Node* from, Node* to){
    adjList[from->id].push_back(to);
  }
  std::vector<std::vector<*Node>> adjList; 
};
```

***
In practice:

```

// Init nodes
Node n1(1); 
Node n2(2); 
Node n3(3); 

// 1 --> 2 --> 3
graph.AddEdge(&n1, &n2);
graph.AddEdge(&n2, &n3);
```

Object Orientated Programming in R?
========================================================

```{r, echo=FALSE, fig.align="center", out.width= "50%"}
   knitr::include_graphics('./please.png')
```

Object Orientated Programming in R
========================================================
incremental: true

S3 Classes:
``` {r}
n1 <- list(id = 1)

class(n1) <- "node"

print.node <- function(obj){
  
  cat("Class:",class(obj),
      "\nID:",obj$id)
}
print(n1)
```

**Benefits:**

* At least there is some kind of structure
* Class specific functions might be useful

Overall: 5/10

Object Orientated Programming in R
========================================================
incremental: true

S4 Classes:
``` {r}
node <- setClass("node", slots=list(id="numeric"))

n1 <- node(id = 1)

print.node <- function(obj){
  
  cat("Class:",class(obj),
      "\nID:",obj@id)
}
print(n1)
```

**Benefits**:

* Typing
* Structured way of creating and interacting with object (even though you're using `@` instread of `$`)

Overall 8/10

Reference Classes (This is where you clap hands)
========================================================
incremental: true

Reference Classes:

``` {r}
node <- setRefClass("nodeR", fields = list(id = "numeric"), 
                     methods = list(
                       show = function(){
                          cat("Node\nID:",id,"\n")
                       }
                     ))
n1 <- node(id = 1)

print(n1)

```

**Benefits**:

* Unlike S3 and S4 methods belong to class
* Able to have pointer like functionality
* Powerful abstraction layer

Overall 10/10 !


========================================================

```{r, echo=FALSE, fig.align="center", out.width= "80%"}
   knitr::include_graphics('./attention.jpg')
```

Reference Classes: Under the hood
========================================================
incremental: true

Things to note:

- Under the hood:
  - A **S4** class
  - It's own **environment**
  
```{r, echo=FALSE, out.width= "50%"}
   knitr::include_graphics('./refClass.png')
```

- Variables are **references** to underlying objects

***
Why worry?

Copying reference classes:
```{r}
n1 <- node(id = 1)
n1
```

Wrong way to copy:
```{r}
n2 = n1
n2$id <- 2
n1
```
```{r,echo = F}
n1 <- node(id = 1)
```

```{r, echo=FALSE, fig.align="center",out.width= "50%"}
   knitr::include_graphics('./copyRef.png')
```


Reference Classes: Under the hood
========================================================
incremental: true


Right way to copy:
```{r}
n2 <- n1$copy()
n2$id <- 2
n1
```




Overengineering for the win
========================================================

The stack:

Let's get this party started?
========================================================
incremental: true

Create some reference classes.

```{r eval=FALSE, fig.align="cener"}
g<- dag()
g$load_from_file('classic_bst')
g$plot()
```
<iframe src="bst_no_heirarchy.html", width = 100%></iframe>

Other projections
========================================================
incremental: true

Create some reference classes.

```{r eval=FALSE}
g$plot_heirarchy()
```
<iframe src="bst_heirarchy.html"></iframe>
- Create **reference class** objects
  - Nodes
  - Edges
  - DAG
- Implement algorithms using **Rpp**
  - Shortest path
  - Path with highest awesomeness value
- Visualise graphs using **d3** 
- BONUS ROUND: Create presentation using **knitR** 

***
```{r, echo=FALSE, fig.align="center",out.width= "50%"}
   knitr::include_graphics('./chuckApprove.jpeg')
```


Let's get this party starting?
========================================================
incremental: true


State:
```{r}

state <- setRefClass("vertex", fields = list(id = "numeric", description = "character"), 
                     methods = list(
                       show = function(){
                          cat("State\nDescription:",description, "\nID:",id,"\n")
                       }
                     ))
                     
```

Transition:
``` {r}

transition <- setRefClass("edge", fields = list(from = "vertex", to = "vertex", weight = "numeric", description ="character"),
                          methods = list(
                            show = function(){
                              cat("Edge\nDescription:",description,"\nWeight:",weight, "\nFrom:\n")
                              from$show()
                              cat("To:\n")
                              to$show()
                            })
)

```


DAG:
``` {r}
adjList <- setRefClass("adjList", fields = list(adjs = "list"),
                       methods = list(
                         addEdge = function(e){
                           if(!("edge" %in% class(e))){
                             stop("Cannot add non edge class to adjacency list")
                           }
                           vName <- paste0("v",e$from$id)
                           adjs[[vName]] <<- c(adjs[[vName]],e$to$id)
                           cat("Edge Added")
                         },
                         show = function(){
                           vNames <- names(adjs)
                           for(vN in vNames){
                            cat("Vertex:",vN,"\n")
                            cat("Adjs:",adjs[[vN]],"\n")
                           }
                         }
                       )
                       )

dag <- setRefClass("dag", fields = list( vertices = "list", edges = "list", adjList = "adjList", vertexCount = "numeric"),
                  methods = list(
                    newVertex = function(description){
                      v <- state(id = vertexCount, description = description )
                      vertexCount <<- vertexCount + 1
                      vertices <<- c(vertices,v)
                      return(v)
                    },
                    createTransition = function(from, to, weight, description){
                      
                      e <- transition(from = from, to = to, weight= weight, description = description)
                      edges <<- c(edges,e)
                      adjList$addEdge(e)
                      
                      return(e)
                    }
                  ))
```



In action
========================================================
incremental: true
```{r}
g <- dag(vertexCount = 0)

awake <- g$newVertex(description = "Awake")
awake

dressedA <- g$newVertex(description = "DressedA")
dressedA

dressedB <- g$newVertex(description = "DressedB")
dressedB

getDressedA <- g$createTransition(from = awake,to = dressedA, weight = 1, description = "Getting pretty")
getDressedA

getDressedB <- g$createTransition(from = awake,to = dressedB, weight = 0.5, description = "Getting cool")

```



